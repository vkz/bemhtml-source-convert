var ometajs = require('ometajs'),
    bemhtml = require('./bemhtml'),
    BEMHTMLToXJST = bemhtml.BEMHTMLToXJST,
    BEMHTMLParser = bemhtml.BEMHTMLParser,
    lo = require('lodash');

function out() {
    console.log.apply(null, [">>> out::\n"].concat(lo.toArray(arguments), ['\n']));
}

ometa Parser <: BEMHTMLParser {

    // behavior described below makes redefinition of and super-calls
    // to left-recursive rules useless or at least non-obvious

    // why the hell does this return the same e: ['this'] when invoked
    // with parser.matchAll("this.ctx.url", 'asgnExpr') - case of
    // left-recusive application. Could it be returning a cashed value
    // from lr-growing algo, or the other way arround i.e. e here
    // can't lookup the value in cash and reports only the value
    // stored in the outer scope. Latter seems more likely - read next
    // comment
    memberExpr =  ^memberExpr:e {out('member: ', e);} -> e,

    // p: reports ['this'] the first time
    // p: reports ['getp', [ 'string', 'ctx' ], [ 'this' ] ] the second
    // which is reasonable, note however that p: is the result of
    // memberExpr application, so one would expect e: from the rule
    // above be the same as p: here
    dotProp :p   = "[" expr:i "]" {out('prop of: ', p)}                                                     -> [#getp, i, p]
        | "." "name":f {out('prop of: ', p)}                                                       -> [#getp, [#string, f], p]
        | "." spaces @iName:f isKeyword(f) {out('prop of: ', p)}                                   -> [#getp, [#string, f], p],

    asgnExpr = ^asgnExpr,
    topLevel  = ^topLevel

}
