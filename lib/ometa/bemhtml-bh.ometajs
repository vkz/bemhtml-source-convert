var ometajs = require('ometajs'),
    xjstid = require('xjst').XJSTIdentity,
    bemhtml = require('./bemhtml'),
    bsjsid = ometajs.grammars.BSJSIdentity,
    bsjstranslator = ometajs.grammars.BSJSTranslator,
    BEMHTMLToXJST = bemhtml.BEMHTMLToXJST,
    BEMHTMLParser = bemhtml.BEMHTMLParser,
    util = require('util'),
    assert = require('assert'),
    bemname = require('bem-naming'),
    lo = require('lodash');

function out() {
    console.log.apply(null, ["!!! out::"].concat(lo.toArray(arguments), ['\n']));
}

// copy-paste of convert.utils.pp
function prettyPrint(obj) {
    var wrappedObj = lo.isString(obj) && obj || util.inspect(obj, {depth: 300, colors: false}),
    len = lo(wrappedObj.split('\n')).
        map(function(s) {return s.length;}).
        max().
        value(),
    prefix = (new Array(len)).join('<').magenta.bold,
    postfix = (new Array(len)).join('>').cyan.bold;
    console.log(prefix);
    console.log(wrappedObj);
    console.log(postfix);
}

function Classes() {
    this.c1 = [];
    this.c2 = [];
    this.c3 = [];
}

Classes.prototype._bemFields = ['block', 'elem', 'mods', 'elemMods', '_mode', '_buf'];


Classes.prototype.addClass = function addClass(subClass) {
    // subClass is "1.2" ==> "1" ==> "c1"
    this['c' + subClass.split('.').shift()].push(subClass);
};

Classes.prototype.classifyPredic = function classifyPredic(predicObj) {
    predicObj.ctx && this.addClass('2.1');
    predicObj.bem && this.addClass('2.2');
    predicObj.custom && this.addClass('2.3');
}

Classes.prototype.classifyBody = function classifyPredic(bodyObj) {
    bodyObj.ctx && this.addClass('3.2');
    (bodyObj.apply || bodyObj.js) && this.addClass('3.3');
    // if none of ctx, apply, js fields set to true, classify into 3.1
    bodyObj.ctx || bodyObj.apply || bodyObj.js || this.addClass('3.1');

}


ometa Parser <: BEMHTMLParser {

    topLevel  = ^topLevel

}

ometa PredicClassifier <: bsjsid {

    getp = [#string #ctx]:fd [#this]:x {this._predic.ctx = true}                                  -> [#getp, fd, x],

    getp = [#string :s ?(lo.contains(this._bemFields, s))]:fd [#this]:x {this._predic.bem = true} -> [#getp, fd, x],

    getp = [#string :s ?(lo.isString(s))]:fd [#this]:x {this._predic.custom = true}               -> [#getp, fd, x],

    getp = ^getp,

    classifyPredic :bemFields
                   %(this._predic = {'ctx': false, 'bem': false, 'custom': false})
                   %(this._bemFields = bemFields)
         = trans                                                                                  -> this._predic

}

ometa BodyClassifier <:  xjstid {

    getp = [#string #ctx]:fd [#this]:x {this._body.ctx = true}  -> [#getp, fd, x],
    getp = ^getp,

    nhApplyStmt :p {this._body.apply = true} -> [#nhApplyStmt, p],
    nhApplyExpr    {this._body.apply = true} -> [#nhApplyExpr],
    applyStmt :p   {this._body.apply = true} -> [#applyStmt, p],

    localStmt trans:as trans:t {this._body.apply = true} -> [#localStmt, as, t],
    localExpr trans:as trans:t {this._body.apply = true} -> [#localExpr, as, t],

    classifyBody %(this._body = {'ctx': false, 'apply': false, 'js': false}) = trans -> this._body
}

ometa Classifier <: BEMHTMLToXJST {

    // each predicate starts with this prefix - artefact of parsing
    // step which should be ignored for classification
    bhPredic = [ #xjst [ 'unop' '!' [ 'getp' [ 'string' 'elem' ] [ 'this' ] ] ]:e ]         -> e,

    bhPredic = [ #xjst :e ]
               { this._class.classifyPredic(
                   PredicClassifier.match(e, 'classifyPredic', [this._class._bemFields])) } -> e,

    bhPredic = ^bhPredic,

    bhBody = [#body [#begin [#stmt anything*]]:b] {this._class.addClass('3.3')}             -> b,

    bhBody = [#body :b]
             { this._class.classifyBody(
                 BodyClassifier.match(b, 'classifyBody')) }                                 -> b,

    bhBody = {this._class.addClass('3.1')} ^bhBody,

    topLevel %( this._class = new Classes())
             = ^topLevel:t
               {this._class.addClass(t.length > 1 ? '1.2' : '1.1');}                        -> [].concat([this._class],t)

}

// invoke with XastToBh.match(..) NOT matchAll
ometa XastToBh <: bsjstranslator {

    // 'this.ctx' in bemhtml becomes 'json' in bh (same as 'ctx.json' in bh)
    getp = [ 'string' 'ctx' ] [ 'this' ] trans(['get', 'json'])
        | ^getp,

    block [ 'binop' '===' [ 'getp' [ 'string' 'block' ] [ 'this' ] ] trans:b ] ->  [#block, b],
    elem  [ 'binop' '===' [ 'getp' [ 'string' 'elem'  ] [ 'this' ] ] trans:b ] ->  [#elem, b],

    // block modifier
    mods [ 'binop' '==='
           [ 'getp' trans:m [ 'getp' [ 'string' 'mods' ] [ 'this' ] ] ]
           trans:v ]                                                           ->  [#blockMode, m, v],

    // elem modifier
    elemMods [ 'binop' '==='
               [ 'getp' trans:e [ 'getp' [ 'string' 'elemMods' ] [ 'this' ] ] ]
               trans:v ]                                                       ->  [#elemMode, e, v],

    mode  [ 'binop' '===' [ 'getp' [ 'string' '_mode' ] [ 'this' ] ] :b ] ->  [#_mode, b],

    // [#_mode, ['string', 'tag'], body]
    _mode :m :b trans([ 'stmt',
                        [ 'call',
                          [ 'getp', m, [ 'get', 'ctx' ] ],
                          [ 'stmt',
                            [ 'call',
                              [ 'func', null, [], [ 'begin', [ 'stmt', b ] ] ] ] ],
                          ['get', 'true']] ]),

    predicates = [#binop '&&' predicates:l predicates:r] -> l.concat(r)
        | :p trans([#block, p]):b                        -> [b]
        | :p trans([#elem, p]):b                         -> [b]
        | :p trans([#mode, p]):b                         -> [b]
        | :p trans([#mods, p]):b                         -> [b]
        | :p trans([#elemMods, p]):b                     -> [b]
        | trans:r                                        -> [[#pred, r]], //not used anywhere yet

    template = [#template predicates:ps  {this._extractBem(ps)}:p :body trans(p.mode.concat([body])):b] -> {
        p.body = body; p.b = b; return p;
    },

    topLevel = [ template*:ts ] {this._bhMatches(ts)}:ms -> 'module.exports = function(bh) {' + ms + '}'

}

XastToBh.prototype._bhMatches = function _bhMatches(ts) {
    return lo(ts).
        groupBy('bem').
        map(this._nestTemplates).
        reduce(function(a, s){return a + s;}, '');
}

XastToBh.prototype._between = function _between(ar, sep, sepSecond) {
    var len = ar.length;
    sep = sep ? sep : '"_"';
    function separator(v) {return sep};
    return sepSecond ?
        lo.flatten(lo.zip(ar, lo.range(len).map(separator)).slice(0, len - 1)) : //chop off redundant sep
        lo.flatten(lo.zip(lo.range(len).map(separator), ar));
}

// NB!! ugly and prone to mistakes
XastToBh.prototype._nestTemplates = function _nestTemplates(ts, bem) {
    var that = this; console.log('!!!', this._between);

    function diffPredicates(from, which) {
        return lo.reject(
            from,
            function (pf) {return lo.any(which,
                              function (pw) {return lo.isEqual(pf, pw)})})}

    function _nestTemplate(ts, predicates) {
        var t, restOfPredicates;
        // no more templates, we're done with recursion
        if (lo.isEmpty(ts)) {return '';}

        t = lo.first(ts);
        // top level - first call to nestTemplate
        if (typeof predicates === 'undefined') {
            return 'bh.match(' + bem + ', function (ctx, json) {'  +                // concat
            'if (' + t.predicates.join(' && ') + ') {' +                     // concat
                t.b + ';' + _nestTemplate(lo.rest(ts), t.predicates) + '}' + '});'; // concat
        }

        // nesting
        restOfPredicates = diffPredicates(t.predicates, predicates);
        if (restOfPredicates.length > 0) {
            return 'if(' + restOfPredicates.join(' && ') + '){' +        // concat
            t.b + ';' + _nestTemplate(lo.rest(ts), lo.union(predicates, restOfPredicates)) + '}'; // concat
        } else {
            return t.b + '; ' + _nestTemplate(lo.rest(ts), lo.union(predicates, restOfPredicates));
        }
    }

    return _nestTemplate(ts);
}

// Example: concatCodeStrings('"hi"', '"_"', '"bob"') returns '"hi_bob"'
XastToBh.prototype._concatCode = function concatCodeStrings() {
    return JSON.stringify(
        lo(arguments).
            toArray().
            flatten().
            map(JSON.parse).
            reduce(function(ac, s) {return ac + s;}, ''));
}

XastToBh.prototype._extractBem = function extractBem(predicates) {
    var block     = [],
        blockMode = [],
        elem      = [],
        elemMode  = [],
        preds     = [],
        mode;
    // function _between(ar, sep) {
    //     sep = sep ? sep : '"_"';
    //     function separator(v) {return sep};
    //     return lo.zip(
    //         lo.range(ar.length).map(separator),
    //         ar);
    // }
    predicates.forEach(function(p) {
        var head = p[0],
        rest = lo.rest(p),
        len = rest.length,
        sep = '"_"';
        switch(head) {
        case 'block':
            block.push(rest);
            break;
        case 'elem':
            elem.push('"__"', rest);
            break;
        case 'blockMode':
            blockMode.push(this._between(rest, sep));
            break;
        case 'elemMode':
            elemMode.push(this._between(rest, sep));
            break;
        case '_mode':
            mode = p;
            break;
        default: preds.push(rest);
        };
    });
    return {bem: this._concatCode(block, blockMode, elem, elemMode),
            predicates: preds,
            mode: mode};
}
