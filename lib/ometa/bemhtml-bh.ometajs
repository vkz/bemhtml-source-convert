var ometajs = require('ometajs'),
    bemhtml = require('./bemhtml'),
    BEMHTMLToXJST = bemhtml.BEMHTMLToXJST,
    BEMHTMLParser = bemhtml.BEMHTMLParser,
    lo = require('lodash');

function out() {
    console.log.apply(null, [">>> out::"].concat(lo.toArray(arguments), ['\n']));
}


function Classes() {
    this.c1 = [];
    this.c2 = [];
    this.c3 = [];
}

Classes.prototype._bemFields = (function (bemFields) {
    return lo.zipObject(
        bemFields,
        bemFields.map(function test(field) {
            var re = new RegExp('\\bthis\\.' + field + '\\b');
            return function(str) { return re.test(str) };
        }));
})(['block', 'elem', 'mods', 'elemMods', '_mode', '_buf']);


Classes.prototype.addClass = function addClass(subClass) {
    // subClass is "1.2" ==> "1" ==> "c1"
    this['c' + subClass.split('.').shift()].push(subClass);
};

Classes.prototype.hasCustomFields = function hasCustomFields(prAsString) {
    // ??? do custom fields always start with this._ ???
    // If not the case, this function is incorrect
    var fields = prAsString.match(/\bthis\._\w+\b/g) || [],
        bemFields = this._bemFields,
        notModeOrBuf = function(field) {
            return !(bemFields._mode(field) ||
                     bemFields._buf(field));
        };
    return !lo.isEmpty(fields.filter(notModeOrBuf));
};

Classes.prototype.hasBemFields = function hasBemFields(prAsString) {
    return lo.some(this._bemFields, function (test, key) {
        return test(prAsString);
    });
};

Classes.prototype.hasThisCtx = function hasThisCtx(prAsString) {
    return (/\bthis\.ctx\b/).test(prAsString);
};

// checks if a tree (array) contains a given subtree (any JS value)
function contains(tree, sub) {
    return lo.some(tree,
                   function(t) {
                       return lo.isEqual(t, sub) ||
                           lo.isArray(t) &&
                           contains(t, sub);
                   });
}

Classes.prototype.contains = contains;

Classes.prototype.addAsgnExpr = function addAsgnExpr(e) {
    // cash parsed this.ctx to avoid expesive computation
    // on each invocation
    var ctxSubtree = this.cash.ctxSubtree ||
        (this.cash.ctxSubtree = BEMHTMLParser.matchAll(
            'this.ctx',
            'asgnExpr'),
         this.cash.ctxSubtree);
    this.asgnExpr.push(e);
    // apply, applyNext, applyCtx in the body
    if(this.contains (e, "nhApplyStmt")) { this.addClass('3.3');}
    // technically can go in the else branch of the above if(), just
    // choosing not to lose information unless really don't need it
    this.addClass(this.contains(e, ctxSubtree) ?
                  '3.2' :
                  '3.1');
    return e;
}

Classes.prototype.addStmt = function addStmt(e) {
    this.stmt.push(e);
    this.addClass('3.3');
    return e;
}

Classes.prototype.addBody = function addBody(e) {
    this.body.push(e);
    return e;
}

Classes.prototype.addPredicate = function addPredicate(ast) {
    var prAsString = typeof ast === 'string' ? ast : XJSTCompiler.match(ast, 'trans');
    this.pr[prAsString] = ast;

    this.hasThisCtx(prAsString) && this.addClass('2.1');
    this.hasBemFields(prAsString) && this.addClass('2.2');
    this.hasCustomFields(prAsString) && this.addClass('2.3');
    return ast;
};

ometa Parser <: BEMHTMLParser {

    bemCustom %(this._predicate = true) = ^bemCustom,

//    dotProp :p = {out ("dot of ", p)} ^dotProp(p):m {out("member ", m)},

    dotProp :p = ^dotProp(p):r -> r,

    asgnExpr = ^asgnExpr,

    topLevel  = ^topLevel

}

ometa Classifier <: BEMHTMLToXJST {

    // bhPredic = [#block :e] {out("#block: e", e)} ^bhPredic([#block, e]),

    // bhPredic = [#blockMod :m :v] {out("#blockmod: m v", m, v)} ^bhPredic([#blockMod, m, v]),

    // bhPredic = [#elem :e] {out("#elem: e", e)} ^bhPredic([#elem, e]),

    // bhPredic = [#elemMod :m :v] {out("#elemMod: m v", m, v)} ^bhPredic([#elemMod, m, v]),

    // bhPredic = [#xjst :e] {out("#xjst: e", e)} ^bhPredic([#xjst, e]),

    // bhPredic = [:m] {out("_mode: m", m)} ^bhPredic([m]),

    bhPredic = ^bhPredic,

    topLevel %( this._class = new Classes()) = ^topLevel:t {
        this._class.addClass(t.length > 1 ? '1.2' : '1.1');} -> [].concat([this._class],t)


}
