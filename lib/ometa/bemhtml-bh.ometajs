var ometajs = require('ometajs'),
    bp = require('../bp'),
    pp = bp.pp;
    xjstid = require('xjst').XJSTIdentity,
    bemhtml = require('./bemhtml'),
    bsjsid = ometajs.grammars.BSJSIdentity,
    bsjstranslator = ometajs.grammars.BSJSTranslator,
    BEMHTMLToXJST = bemhtml.BEMHTMLToXJST,
    BEMHTMLParser = bemhtml.BEMHTMLParser,
    util = require('util'),
    assert = require('assert'),
    colors = require('colors'),
    lo = require('lodash');

ometa Parser <: BEMHTMLParser {

    topLevel = ^topLevel

}

ometa PredicClassifier <: bsjsid {

    getp = [#string #ctx]:fd [#this]:x {this._predic.ctx = true} -> [#getp, fd, x],

    getp = [#string :s ?(lo.contains(this._bemFields, s))]:fd [#this]:x {this._predic.bem = true}
        -> [#getp, fd, x],

    getp = [#string :s ?(lo.isString(s))]:fd [#this]:x {this._predic.custom = true}
        -> [#getp, fd, x],

    getp = ^getp,

    classifyPredic :bemFields
                   %(this._predic = {'ctx': false, 'bem': false, 'custom': false})
                   %(this._bemFields = bemFields)
         = trans -> this._predic
}

ometa BodyClassifier <:  xjstid {

    getp = [#string #ctx]:fd [#this]:x {this._body.ctx = true}  -> [#getp, fd, x],
    getp = ^getp,

    nhApplyStmt :p {this._body.apply = true} -> [#nhApplyStmt, p],
    nhApplyExpr    {this._body.apply = true} -> [#nhApplyExpr],
    applyStmt :p   {this._body.apply = true} -> [#applyStmt, p],

    localStmt trans:as trans:t {this._body.apply = true} -> [#localStmt, as, t],
    localExpr trans:as trans:t {this._body.apply = true} -> [#localExpr, as, t],

    classifyBody %(this._body = {'ctx': false, 'apply': false, 'js': false}) = trans -> this._body
}

ometa Classifier <: xjstid {

    bhPredic = [(#block | #blockMod | #elem | #elemMod):h anything+]:b -> b,

    bhPredic = [ #xjst
                 ([ 'unop' '!' [ 'getp' [ 'string' 'elem' ] [ 'this' ] ] ]
                  | :e {
                      this.
                          _class.
                          classifyPredic(
                              PredicClassifier.match(e, 'classifyPredic', [this._class._bemFields]));
                      return e;}) ]:b -> b,

    bhPredic = [:m] -> [m],

    bhBody = [#body [#begin [#stmt anything*]]]:b {this._class.addClass('3.3')} -> b,

    bhBody = [#body :b {
        this._class.classifyBody(BodyClassifier.match(b, 'classifyBody'));
        this._class.addClass('3.1') }] -> [#body, b],

    bhTemplate = [bhPredic+:ps bhBody:b] -> ps.concat([b])
        | [#stmt anything]:r -> r,

    start = [bhTemplate+:ts] -> ts,
    start = bhTemplate:t -> t,
    start = end -> [],

    topLevel %( this._class = new bp.Classes()) = start:t {
        this._class.addClass(t.length > 1 ? '1.2' : '1.1');
        this._class.uniq();}
        -> this._class

}

ometa XastToBh <: bsjstranslator {

    // avoid throwing inside rules, causes some really weird and difficult to track behaviour in ometa
    // better let ometa matcher fail with 'rule not found'
    //localExpr = anything* -> {(function(){throw({error: undefined, message: 'localExpr() not supported yet'})})();},

    // trans :p = {console.log('Trans:' + pp(p, {stringify: true}))} ^trans(p),

    getp = [ 'string' 'ctx' ] [ 'this' ] trans(['get', 'json'])
        | [ 'string' 'position' ]:p [ 'this' ] trans([#call, [#getp, p, [#get, 'ctx']]])
        | [ 'string' ('isFirst' | 'isLast' |'generateId') ]:p [ 'this' ] trans([#getp, p, [#get, 'ctx']]),

    // bemFields 'block' and 'elem'
    getp = ['string' ('block' | 'elem')]:p ['this'] trans([#getp, p, ['get', 'json']]),

    // this.mods and this.elemMods getter e.g. this.mods.layout
    getp = :p mods trans([#call, [#getp, [#string, 'mod'], [#get, 'ctx']], p]),

    // this should catch context independent fields
    // this._.isSimple into ctx.isSimple
    // this._.extend into ctx.extend
    getp =  ['string' '_'] ['this'] trans([#get, 'ctx']),

    // assume custom field e.g. this._bla
    getp = :p [ 'this' ]  trans([#call, [#getp, [#string, 'tParam'], [#get, 'ctx']], p])
        | ^getp,

    // this.mods and this.elemMods setter e.g. this.mods.layout = true
    set = [ 'getp' :p mods ] :v trans([#call, [#getp, [#string, 'mod'], [#get, 'ctx']], p, v]),

    // custom field setter e.g. this._bla = val
    set = ['getp' :p ['this']] :v trans([#call, [#getp, [#string, 'tParam'], [#get, 'ctx']], p, v]),

    set = ^set,

    mods = [ 'getp' [ 'string' ('mods' | 'elemMods') ] [ 'this' ] ],

    // _mode :m :b trans([ 'stmt', [ 'call', [ 'getp', m, [ 'get', 'ctx' ] ], b, [ 'get', 'true' ]] ]),

    // don't force when ctx.mix() mode
    force = [#string #mix] -> 'false'
        | anything -> 'true',

    _mode :m :b force(m):f
    trans([ 'stmt', [ 'call', [ 'getp', m, [ 'get', 'ctx' ] ], b, [ 'get',  f]] ]),

    bhPredic = [(#block | #blockMod | #elem | #elemMod):h trans+:b] -> [h].concat(b),
    bhPredic = [:m] -> [#_mode, [#string, m]],
    bhPredic = [#xjst trans:e] -> [#pred, e],

    bhBody = [#body [#begin [#return :b]]] -> b,

    // temp33_c case [body [begin [stmt ..] [stmt ..]]]
    // wrap arbitrary js in iif
    bhBody = [#body :b] -> [ 'call', [ 'func', null, [], b ] ],

    notElem = [#xjst [ 'unop' '!' [ 'getp' [ 'string' 'elem' ] [ 'this' ] ] ]],

    bhTemplate = [notElem? bhPredic+:ps {this._extractBem(ps)}:p  bhBody:body
                  trans(p.mode.concat([body])):b]
        -> { p.body = body; p.b = b; return p; },

    topLevel = [ bhTemplate+:ts ] {this._bhMatches(ts)}:ms
        -> new bp.Bh('module.exports = function(bh) {' + ms + '}')

}

XastToBh.prototype._extractBem = function extractBem(predicates) {
    var block     = [],
    blockMod = [],
    elem      = [],
    elemMod  = [],
    preds     = [],
    mode,
    that = this;

    predicates.forEach(function(p) {
        var head = p[0],
        rest = lo.rest(p),
        len = rest.length,
        sep = '"_"';
        switch(head) {
        case 'block':
            block.push(rest);
            break;
        case 'elem':
            elem.push('"__"', rest);
            break;
        case 'blockMod':
            blockMod.push(that._between(rest, sep));
            break;
        case 'elemMod':
            elemMod.push(that._between(rest, sep));
            break;
        case '_mode':
            mode = p;
            break;
        default: preds.push(rest);
        };
    });
    return {bem: that._concatCode(block, blockMod, elem, elemMod),
            predicates: preds,
            mode: mode};
}

XastToBh.prototype._bhMatches = function _bhMatches(ts) {
    var result = lo(ts).
        groupBy('bem').
        map(this._nestTemplates).
        reduce(function(a, s){return a + s;}, '');
    return result;
}

XastToBh.prototype._between = function _between(ar, sep, sepSecond) {
    var len = ar.length;
    sep = sep ? sep : '"_"';
    function separator(v) {return sep};
    return sepSecond ?
        lo.flatten(lo.zip(ar, lo.range(len).map(separator)).slice(0, len - 1)) : //chop off redundant sep
        lo.zip(lo.range(len).map(separator), ar);
}

// might be sensible to rewrite this using xjst, seeing how it its pattern
XastToBh.prototype._nestTemplates = function _nestTemplates(ts, bem) {

    function diffPredicates(from, which) {
        return lo.reject(
            from,
            function (pf) {return lo.any(which,
                              function (pw) {return lo.isEqual(pf, pw)})})}

    function _nestTemplate(t, predicates) {
        var t, restOfPredicates;

        // nesting
        restOfPredicates = diffPredicates(t.predicates, predicates);
        return restOfPredicates.length > 0 ?
            'if(' + restOfPredicates.join(' && ') + '){' +
            _nestTemplate(t, lo.union(predicates, restOfPredicates)) + '}' :
            t.b + ';';
    }

    return 'bh.match(' + bem + ', function (ctx, json) {'  +
        ts.
        map(function(t) {return _nestTemplate(t, []);}).
        reduce(function(a, s){return a + s;}) + '});';
}

// Example: concatCodeStrings('"hi"', '"_"', '"bob"') returns '"hi_bob"'
XastToBh.prototype._concatCode = function concatCodeStrings() {
    return JSON.stringify(
        lo(arguments).
            toArray().
            flatten().
            map(JSON.parse).
            reduce(function(ac, s) {return ac + s;}, ''));
}
