var ometajs = require('ometajs'),
    bp = require('../bp'),
    pp = bp.pp;
    xjstid = require('xjst').XJSTIdentity,
    bsjsparser = ometajs.grammars.BSJSParser,
    bsjsid = ometajs.grammars.BSJSIdentity,
    bsjstranslator = ometajs.grammars.BSJSTranslator,
    compatBemhtmlParser = require('../../node_modules/bemhtml-compat/lib/ometa/bemhtml').BEMHTMLParser,
    compatJail = require('../../node_modules/bemhtml-compat/lib/ometa/jail').Jail,
    util = require('util'),
    lo = require('lodash'),
    isBemField = lo.curry(lo.contains, ['block', 'elem', 'mods', 'elemMods', '_mode', '_buf']);

ometa PredicClassifier <: bsjsid {
    getp = [#string #ctx] [#this]
            { this._predic.ctx = true }
        | [#string :s ?(isBemField(s))] [#this]
                { this._predic.bem = true }
        | [#string anything] [#this]
                { this._predic.custom = true }
        | ^getp,

    classifyPredic
        %(this._predic = { ctx: false, bem: false, custom: false })
            = trans -> this._predic
}

ometa BodyClassifier <:  xjstid {
    getp = [#string #ctx] [#this]
            { this._body.ctx = true } |
        ^getp,

    nhApplyStmt :p { this._body.apply = true },
    nhApplyExpr { this._body.apply = true },
    applyStmt :p { this._body.apply = true },

    localStmt trans:as trans:t { this._body.apply = true },
    localExpr trans:as trans:t { this._body.apply = true },

    classifyBody
        %(this._body = { ctx: false, apply: false, js: false })
            = trans -> this._body
}

ometa Classifier <: xjstid {
    notElemPredic = [#unop '!' [#getp [#string #elem] [#this]]],
    customJsPredic = :p -> PredicClassifier.match(p, 'classifyPredic'),
    bhXjstPredic = [#xjst (
            notElemPredic
            | customJsPredic:p { this._class.classifyPredic(p) }
        )],

    bemPredic = [(#block | #blockMod | #elem | #elemMod) anything+],

    modePredic = [anything],

    bhPredic = bemPredic | bhXjstPredic | modePredic,

    customJsBody = [#begin [#stmt anything*]],
    anyBody = :b -> BodyClassifier.match(b, 'classifyBody'),
    bhBody = [#body (
            customJsBody
                { this._class.addClass('3.3') }
            | anyBody:b
                { this._class.addClass('3.1').classifyBody(b) }
        )],

    bhTemplate = [bhPredic+ bhBody] | [#stmt anything],

    start = [bhTemplate+] | bhTemplate | end,

    topLevel
        %(this._class = new bp.Classes())
            = start -> this._class
}

ometa Jail <: compatJail {
    applyNext trans:e -> [#applyNext, e],
    applyNext -> [#applyNext],
    applyCtx trans:e -> [#applyCtx, e],
    topLevel = ^topLevel:r -> r
}

ometa Parser <: compatBemhtmlParser {
    applyCase = "applyNext" "(" ")" -> [#applyNext]
        | "applyNext" "(" expr:e ")" -> [#applyNext, e]
        | "applyCtx" "(" expr:ctx ")" -> [#applyCtx, ctx],

    primExprHd = applyCase | ^primExprHd,

    stmt = applyCase | ^stmt,

}

// make sure my custom Jail grammar is called from parser's listBemMatchAndSet rule
Parser.prototype._jail = Jail;

ometa HashArg <: bsjsid {
    json trans*:props -> ([#seqStmts].concat(props)),
    binding :name {Parser.matchAll('this.' + name, 'stmt')}:prop :val -> ([#set, prop, val]),
}

// consider refactoring this grammar into a tree transformer with a
// separate one responsible for code generation
ometa XastToBh <: bsjstranslator {

    warn :msg = { this.pushWarn(msg) },

    // bemhtml parser adds an extra 'undefined' statement to some template bodies
    // ignore them
    stmt [#get #undefined] -> '',
    stmt = ^stmt,

    seqStmts = trans*:ts
        ->  lo.reduce(ts, function(ac, stmt) { return ac + stmt + (stmt ? ';' : '') }, ''),

    contextMethods = 'isFirst' | 'isLast' | 'generateId' | 'extend' | 'isSimple',
    thisCtx = [ 'string' 'ctx' ] [ 'this' ],
    thisPosition = [ 'string' 'position' ]:p [ 'this' ] -> p,
    thisMethods = [ 'string' contextMethods ]:m [ 'this' ] -> m,
    thisBlockOrElem = ['string' ('block' | 'elem') ]:p [ 'this' ] -> p,
    this_mode = ['string' '_mode' ]:p [ 'this' ] -> p,
    this_ = ['string' '_'] ['this'],
    thisMods = [ 'string' ('mods' | 'elemMods') ] [ 'this' ],
    getpThisMods = ['getp' thisMods],

    set = [ #getp :p getpThisMods ] :v trans(this.astOf.mod(p, v))
        | [ #getp :p [ #this ]] :v trans(this.astOf.tParam(p, v))
        | ^ set,

    getp =  thisCtx trans(this.astOf.json)
        | thisPosition:p trans([#call, this.astOf.getp(p)])
        | thisMethods:m trans(this.astOf.getp(m))
        | thisBlockOrElem:p trans(this.astOf.getp(p, this.astOf.json)):res (
                ?(this._isPredic) warn('this.block or this.elem in predicate')  -> res
                | -> res)
        | this_mode:p warn('this._mode detected - bh does not support custom modes')
                trans(this.astOf.getp(p, this.astOf.json)):res -> res
        | this_ trans([#get, 'ctx'])
        | :p getpThisMods trans(this.astOf.mod(p))
        | :p [ #this ]  trans(this.astOf.tParam(p))
        | ^getp,

    applyNext = :e (isMode('default') {HashArg.match(e, 'trans')}:arg trans(arg)
                     | warn('returning result of applyNext(args)'))
        | ~isMode('default') warn('returning result of applyNext()') trans(this.astOf[this._m]())
        | isMode('default') -> '',

    applyCtx = :e trans([#return, e]),

    force -> ['get', 'true'],
    isJson [#json (anything*)],
    isArray [#arr (anything*)],
    mixBody :b = (isJson(b) -> [#arr, b]
                  | isArray(b) -> b
                  | warn('in mix: expected an Object or an Array')),
    jsBody trans:body -> this.parse('this.ctx.js !== false ? this.extend(this.ctx.js,' + body + ') : false'),

    attrsBody :body -> this.astOf.callMethod('extend', ['this'])(body, this.astOf.attrs()),

    _mode %(this._m = '') = [#string :m { this._m = m }] bhBody:body (
        isMode('default') trans(body)
        | isMode('mix') mixBody(body):mbody trans([
                #stmt,
                this.astOf.mix(
                    this.astOf
                        .callMethod('concat', mbody)(this.astOf.mix()))
            ])
        | isMode('js') jsBody(body):jsbody trans([#stmt, this.astOf.js(jsbody)])
        | isMode('attrs') attrsBody(body):abody trans([#stmt, this.astOf.attrs(abody)])
        | force:f trans([ #stmt, this.astOf.callCtx(m)(body, f) ])),

    isMode :m = ?(this._m === m),

    bhBody = [#body [#begin [#return :b]]] -> b
        | [#body [#begin [#stmt [#return :b]]]] -> b
        | [#body [#begin (anything*):ss]] isMode('default') -> ([#seqStmts].concat(ss))
        | [#body :b] -> this.astOf.iif(b),

    bemPredic = [(#block | #blockMod | #elem | #elemMod):h trans+:b] -> [h].concat(b),
    modePredic = [:m] -> [#_mode, [#string, m]],
    notElemPredic = [#xjst [#unop '!' [#getp [#string #elem] [#this]]]] -> [#_notElemPredic],
    customJsPredic = [#xjst trans:e] -> [#pred, e],
    bhPredic
        %(this._isPredic = true)
            = bemPredic | modePredic | notElemPredic | customJsPredic,

    bhTemplate = [
        bhPredic+:ps
        { this._extractBem(ps) }:p
        :body
        trans(p.mode.concat([body])):b ]
            -> { p.body = body; p.b = b; return p; },

    topLevel = [bhTemplate+:ts] { this._bhMatches(ts) }:ms
        -> {
            if(this.warnings) {
                var err = new Error();
                err.warnings = this.warnings;
                err.message = 'Problems detected\n' + bp.formatWarnings(err);
                throw err;
            }
            return new bp.Bh('module.exports = function(bh) {' + ms + '}');
        }
}

function astOfCall(method, ofWhat) {
    return function() {
        return ['call', ['getp',
                lo.isString(method)? ['string', method] : method,
                lo.isString(ofWhat)? ['get', ofWhat] : ofWhat]
            ].concat(lo.toArray(arguments));
    }
}

var astOfCtxCall = lo.partialRight(astOfCall, 'ctx');

XastToBh.prototype.pushWarn = function pushWarn(msg) {
    (this.warnings || (this.warnings = [])).push(msg);
    // report accumulated warnings if ometa rule-matching fails
    // see grammars.js in ometa-js for details
    (this._errorStack || (this._errorStack = new Error()))
        .warnings = this.warnings;
}

XastToBh.prototype.parse = function parse(code) {
    return bsjsparser.matchAll(code, 'stmt');
}

XastToBh.prototype.astOf = lo.merge(
    ['content', 'applyBase', 'mod', 'attrs', 'tParam', 'mix', 'js'].reduce(function(acc, n) {
        acc[n] = astOfCtxCall(n);
        return acc
    }, {}),
    {
        json: ['get', 'json'],
        getp: function(field, from) {
            return ['getp',
                lo.isString(field)? ['stirng', field] : field,
                from || ['get', 'ctx']];
        },
        iif: function(body) { return ['call', [ 'func', null, [], body]];},
        stmt: function() { return ['stmt'].concat(lo.toArray(arguments)); },
        callMethod: astOfCtxCall,
        callCtx: astOfCtxCall
    }
);

XastToBh.prototype._extractBem = function extractBem(predicates) {
    var block = '',
        blockMod = '',
        elem = '',
        elemMod = '',
        mode,
        preds = [];

    function parseRest(rest) {
        var rest1 = JSON.parse(rest[1]);
        return rest.length === 2?
            rest1 :
            rest1 + '_' + JSON.parse(rest[2]);
    }

    predicates.forEach(function(p) {
        var head = p[0];
        switch(head) {
            case 'block':
                block = parseRest(p)
                break;
            case 'elem':
                elem = '__' + parseRest(p);
                break;
            case 'blockMod':
                blockMod = '_' + parseRest(p);
                break;
            case 'elemMod':
                elemMod = '_' + parseRest(p)
                break;
            case '_mode':
                mode = p;
                break;
            case '_notElemPredic':
                break;
            default:
                preds.push(lo.rest(p));
        };
    });
    return {
        bem: block + blockMod + elem + elemMod,
        predicates: preds,
        mode: mode
    };
}

XastToBh.prototype._bhMatches = function _bhMatches(ts) {
    var result = lo(ts)
        .groupBy('bem')
        .map(this._nestTemplates)
        .reduce(function(a, s){ return a + s }, '');
    //pp(lo(ts).groupBy('bem').value(), {prompt: 'grouped'});
    return result;
}

XastToBh.prototype._between = function _between(ar, sep, sepSecond) {
    var len = ar.length;
    sep = sep ? sep : '"_"';
    function separator(v) {return sep};
    return sepSecond ?
        lo.flatten(lo.zip(ar, lo.range(len).map(separator)).slice(0, len - 1)) :             //chop off redundant sep
    lo.zip(lo.range(len).map(separator), ar);
}

// might be sensible to rewrite this using xjst, seeing how it its pattern
XastToBh.prototype._nestTemplates = function _nestTemplates(ts, bem) {

    // find default mode and return it's body-string, empty string otherwise
    // remove it from ts
    function extractDefault() {
        var defMode = [ '_mode', [ 'string', 'default' ] ],
            isDefault = function(t){return lo.isEqual(t.mode, defMode);},
            defIndex = lo.findIndex(ts, isDefault);
        return defIndex >= 0 ? ts.splice(defIndex, 1).pop().b : '';
    }

    function diffPredicates(from, which) {
        return lo.reject(
            from,
            function (pf) {return lo.any(which,
                              function (pw) {return lo.isEqual(pf, pw)})})}

    function _nestTemplate(t, predicates) {
        var t, restOfPredicates;

        // nesting
        restOfPredicates = diffPredicates(t.predicates, predicates);
        return restOfPredicates.length > 0 ?
            'if(' + restOfPredicates.join(' && ') + '){' +
            _nestTemplate(t, lo.union(predicates, restOfPredicates)) + '}' :
            t.b + ';';
    }

    return 'bh.match(' + JSON.stringify(bem) + ', function (ctx, json) {'  +
        extractDefault() + ts
            .map(function(t) {return _nestTemplate(t, []);})
            .reduce(function(a, s){return a + s;}, '') + '});';
}

// Example: concatCodeStrings('"hi"', '"_"', '"bob"') returns '"hi_bob"'
XastToBh.prototype._concatCode = function concatCodeStrings() {
    return JSON.stringify(
        lo(arguments).
            toArray().
            flatten().
            map(JSON.parse).
            reduce(function(ac, s) {return ac + s;}, ''));
}
