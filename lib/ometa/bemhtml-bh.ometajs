var ometajs = require('ometajs'),
    xjstid = require('xjst').XJSTIdentity,
    bemhtml = require('./bemhtml'),
    bsjsid = ometajs.grammars.BSJSIdentity,
    bsjstranslator = ometajs.grammars.BSJSTranslator,
    BEMHTMLToXJST = bemhtml.BEMHTMLToXJST,
    BEMHTMLParser = bemhtml.BEMHTMLParser,
    util = require('util'),
    assert = require('assert'),
    bemname = require('bem-naming'),
    lo = require('lodash');

function out() {
    console.log.apply(null, ["!!! out::"].concat(lo.toArray(arguments), ['\n']));
}

// copy-paste of convert.utils.pp
function pp(obj) {
    var wrappedObj = lo.isString(obj) && obj || util.inspect(obj, {depth: 300, colors: false}),
    len = lo(wrappedObj.split('\n')).
        map(function(s) {return s.length;}).
        max().
        value(),
    prefix = (new Array(len)).join('<').magenta.bold,
    postfix = (new Array(len)).join('>').cyan.bold;
    console.log(prefix);
    console.log(wrappedObj);
    console.log(postfix);
}

function Classes() {
    this.c1 = [];
    this.c2 = [];
    this.c3 = [];
}

Classes.prototype._bemFields = ['block', 'elem', 'mods', 'elemMods', '_mode', '_buf'];


Classes.prototype.addClass = function addClass(subClass) {
    // subClass is "1.2" ==> "1" ==> "c1"
    this['c' + subClass.split('.').shift()].push(subClass);
};

Classes.prototype.classifyPredic = function classifyPredic(predicObj) {
    predicObj.ctx && this.addClass('2.1');
    predicObj.bem && this.addClass('2.2');
    predicObj.custom && this.addClass('2.3');
}

Classes.prototype.classifyBody = function classifyPredic(bodyObj) {
    bodyObj.ctx && this.addClass('3.2');
    (bodyObj.apply || bodyObj.js) && this.addClass('3.3');
    // if none of ctx, apply, js fields set to true, classify into 3.1
    bodyObj.ctx || bodyObj.apply || bodyObj.js || this.addClass('3.1');

}


ometa Parser <: BEMHTMLParser {

    topLevel  = ^topLevel

}

ometa PredicClassifier <: bsjsid {

    getp = [#string #ctx]:fd [#this]:x {this._predic.ctx = true} -> [#getp, fd, x],

    getp = [#string :s ?(lo.contains(this._bemFields, s))]:fd [#this]:x {this._predic.bem = true}
        -> [#getp, fd, x],

    getp = [#string :s ?(lo.isString(s))]:fd [#this]:x {this._predic.custom = true}
        -> [#getp, fd, x],

    getp = ^getp,

    classifyPredic :bemFields
                   %(this._predic = {'ctx': false, 'bem': false, 'custom': false})
                   %(this._bemFields = bemFields)
         = trans -> this._predic
}

ometa BodyClassifier <:  xjstid {

    getp = [#string #ctx]:fd [#this]:x {this._body.ctx = true}  -> [#getp, fd, x],
    getp = ^getp,

    nhApplyStmt :p {this._body.apply = true} -> [#nhApplyStmt, p],
    nhApplyExpr    {this._body.apply = true} -> [#nhApplyExpr],
    applyStmt :p   {this._body.apply = true} -> [#applyStmt, p],

    localStmt trans:as trans:t {this._body.apply = true} -> [#localStmt, as, t],
    localExpr trans:as trans:t {this._body.apply = true} -> [#localExpr, as, t],

    classifyBody %(this._body = {'ctx': false, 'apply': false, 'js': false}) = trans -> this._body
}

ometa Classifier <: xjstid {

    bhPredic = [(#block | #blockMod | #elem | #elemMod):h anything+]:b -> b,

    bhPredic = [ #xjst
                 ([ 'unop' '!' [ 'getp' [ 'string' 'elem' ] [ 'this' ] ] ]
                  | :e {
                      this.
                          _class.
                          classifyPredic(
                              PredicClassifier.match(e, 'classifyPredic', [this._class._bemFields]));
                      return e;}) ]:b -> b,

    bhPredic = [:m] -> [m],

    bhBody = [#body [#begin [#stmt anything*]]]:b {this._class.addClass('3.3')} -> b,

    bhBody = [#body :b {
        this._class.classifyBody(BodyClassifier.match(b, 'classifyBody'));
        this._class.addClass('3.1') }] -> [#body, b],

    bhTemplate = [bhPredic+:ps bhBody:b] -> ps.concat([b])
        | [#stmt anything]:r -> r,

    start = [bhTemplate+:ts] -> ts,
    start = bhTemplate:t -> t,
    start = end -> [],

    topLevel %( this._class = new Classes()) = start:t {
        this._class.addClass(t.length > 1 ? '1.2' : '1.1');} -> [].concat([this._class],t)

}
ometa XastToBh <: bsjstranslator {

    getp = [ 'string' 'ctx' ] [ 'this' ] trans(['get', 'json'])
        | ^getp,

    _mode :m :b trans([ 'stmt', [ 'call', [ 'getp', m, [ 'get', 'ctx' ] ], b, [ 'get', 'true' ]] ]),

    bhPredic = [(#block | #blockMod | #elem | #elemMod):h trans+:b] -> [h].concat(b),
    bhPredic = [:m] -> [#_mode, [#string, m]],
    bhPredic = [#xjst trans:e] -> [#pred, e],

    bhBody = [#body ([#begin [#return :b]]
                     | :b)] -> b,

    notElem = [#xjst [ 'unop' '!' [ 'getp' [ 'string' 'elem' ] [ 'this' ] ] ]],

    bhTemplate = [notElem? bhPredic+:ps {this._extractBem(ps)}:p  bhBody:body
                  trans(p.mode.concat([body])):b]
        -> { p.body = body; p.b = b; return p; }
        | [#stmt anything]:r trans(r),

    topLevel = [ bhTemplate+:ts ] {this._bhMatches(ts)}:ms -> 'module.exports = function(bh) {' + ms + '}'

}

XastToBh.prototype._extractBem = function extractBem(predicates) {
    var block     = [],
    blockMod = [],
    elem      = [],
    elemMod  = [],
    preds     = [],
    mode,
    that = this;

    predicates.forEach(function(p) {
        var head = p[0],
        rest = lo.rest(p),
        len = rest.length,
        sep = '"_"';
        switch(head) {
        case 'block':
            block.push(rest);
            break;
        case 'elem':
            elem.push('"__"', rest);
            break;
        case 'blockMod':
            blockMod.push(that._between(rest, sep));
            break;
        case 'elemMod':
            elemMod.push(that._between(rest, sep));
            break;
        case '_mode':
            mode = p;
            break;
        default: preds.push(rest);
        };
    });
    return {bem: that._concatCode(block, blockMod, elem, elemMod),
            predicates: preds,
            mode: mode};
}

XastToBh.prototype._bhMatches = function _bhMatches(ts) {
    return lo(ts).
        groupBy('bem').
        map(this._nestTemplates).
        reduce(function(a, s){return a + s;}, '');
}

XastToBh.prototype._between = function _between(ar, sep, sepSecond) {
    var len = ar.length;
    sep = sep ? sep : '"_"';
    function separator(v) {return sep};
    return sepSecond ?
        lo.flatten(lo.zip(ar, lo.range(len).map(separator)).slice(0, len - 1)) : //chop off redundant sep
        lo.zip(lo.range(len).map(separator), ar);
}

// might be sensible to rewrite this using xjst, seeing how it its pattern
XastToBh.prototype._nestTemplates = function _nestTemplates(ts, bem) {

    function diffPredicates(from, which) {
        return lo.reject(
            from,
            function (pf) {return lo.any(which,
                              function (pw) {return lo.isEqual(pf, pw)})})}

    function _nestTemplate(ts, predicates) {
        var t, restOfPredicates;
        // no more templates, we're done with recursion
        if (lo.isEmpty(ts)) {return '';}

        t = lo.first(ts);
        // top level - first call to nestTemplate
        if (typeof predicates === 'undefined') {
            return 'bh.match(' + bem + ', function (ctx, json) {'  + _nestTemplate(ts, []) + '});';
        }

        // nesting
        restOfPredicates = diffPredicates(t.predicates, predicates);
        return restOfPredicates.length > 0 ?
            'if(' + restOfPredicates.join(' && ') + '){' +
            _nestTemplate(ts, lo.union(predicates, restOfPredicates)) + ';}' :
            t.b + '; ' + _nestTemplate(lo.rest(ts), lo.union(predicates, restOfPredicates));
    }

    return _nestTemplate(ts);
}

// Example: concatCodeStrings('"hi"', '"_"', '"bob"') returns '"hi_bob"'
XastToBh.prototype._concatCode = function concatCodeStrings() {
    return JSON.stringify(
        lo(arguments).
            toArray().
            flatten().
            map(JSON.parse).
            reduce(function(ac, s) {return ac + s;}, ''));
}
