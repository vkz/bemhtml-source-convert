var ometajs = require('ometajs'),
    xjstid = require('xjst').XJSTIdentity,
    bemhtml = require('./bemhtml'),
    bsjsid = ometajs.grammars.BSJSIdentity,
    bsjstranslator = ometajs.grammars.BSJSTranslator,
    BEMHTMLToXJST = bemhtml.BEMHTMLToXJST,
    BEMHTMLParser = bemhtml.BEMHTMLParser,
    util = require('util'),
    assert = require('assert'),
    bemname = require('bem-naming'),
    lo = require('lodash');

function out() {
    console.log.apply(null, ["!!! out::"].concat(lo.toArray(arguments), ['\n']));
}

// copy-paste of convert.utils.pp
function prettyPrint(obj) {
    var wrappedObj = lo.isString(obj) && obj || util.inspect(obj, {depth: 300, colors: false}),
    len = lo(wrappedObj.split('\n')).
        map(function(s) {return s.length;}).
        max().
        value(),
    prefix = (new Array(len)).join('<').magenta.bold,
    postfix = (new Array(len)).join('>').cyan.bold;
    console.log(prefix);
    console.log(wrappedObj);
    console.log(postfix);
}

function Classes() {
    this.c1 = [];
    this.c2 = [];
    this.c3 = [];
}

Classes.prototype._bemFields = ['block', 'elem', 'mods', 'elemMods', '_mode', '_buf'];


Classes.prototype.addClass = function addClass(subClass) {
    // subClass is "1.2" ==> "1" ==> "c1"
    this['c' + subClass.split('.').shift()].push(subClass);
};

Classes.prototype.classifyPredic = function classifyPredic(predicObj) {
    predicObj.ctx && this.addClass('2.1');
    predicObj.bem && this.addClass('2.2');
    predicObj.custom && this.addClass('2.3');
}

Classes.prototype.classifyBody = function classifyPredic(bodyObj) {
    bodyObj.ctx && this.addClass('3.2');
    (bodyObj.apply || bodyObj.js) && this.addClass('3.3');
    // if none of ctx, apply, js fields set to true, classify into 3.1
    bodyObj.ctx || bodyObj.apply || bodyObj.js || this.addClass('3.1');

}


ometa Parser <: BEMHTMLParser {

    topLevel  = ^topLevel

}

ometa PredicClassifier <: bsjsid {

    getp = [#string #ctx]:fd [#this]:x {this._predic.ctx = true}                                  -> [#getp, fd, x],

    getp = [#string :s ?(lo.contains(this._bemFields, s))]:fd [#this]:x {this._predic.bem = true} -> [#getp, fd, x],

    getp = [#string :s ?(lo.isString(s))]:fd [#this]:x {this._predic.custom = true}               -> [#getp, fd, x],

    getp = ^getp,

    classifyPredic :bemFields
                   %(this._predic = {'ctx': false, 'bem': false, 'custom': false})
                   %(this._bemFields = bemFields)
         = trans                                                                                  -> this._predic

}

ometa BodyClassifier <:  xjstid {

    getp = [#string #ctx]:fd [#this]:x {this._body.ctx = true}  -> [#getp, fd, x],
    getp = ^getp,

    nhApplyStmt :p {this._body.apply = true} -> [#nhApplyStmt, p],
    nhApplyExpr    {this._body.apply = true} -> [#nhApplyExpr],
    applyStmt :p   {this._body.apply = true} -> [#applyStmt, p],

    localStmt trans:as trans:t {this._body.apply = true} -> [#localStmt, as, t],
    localExpr trans:as trans:t {this._body.apply = true} -> [#localExpr, as, t],

    classifyBody %(this._body = {'ctx': false, 'apply': false, 'js': false}) = trans -> this._body
}

ometa Classifier <: BEMHTMLToXJST {

    // each predicate starts with this prefix - artefact of parsing
    // step which should be ignored for classification
    bhPredic = [ #xjst [ 'unop' '!' [ 'getp' [ 'string' 'elem' ] [ 'this' ] ] ]:e ]         -> e,

    bhPredic = [ #xjst :e ]
               { this._class.classifyPredic(
                   PredicClassifier.match(e, 'classifyPredic', [this._class._bemFields])) } -> e,

    bhPredic = ^bhPredic,

    bhBody = [#body [#begin [#stmt anything*]]:b] {this._class.addClass('3.3')}             -> b,

    bhBody = [#body :b]
             { this._class.classifyBody(
                 BodyClassifier.match(b, 'classifyBody')) }                                 -> b,

    bhBody = {this._class.addClass('3.1')} ^bhBody,

    topLevel %( this._class = new Classes())
             = ^topLevel:t
               {this._class.addClass(t.length > 1 ? '1.2' : '1.1');}                        -> [].concat([this._class],t)

}

// invoke with XastToBh.match(..) NOT matchAll
ometa XastToBh <: bsjstranslator {

    block [ 'binop' '===' [ 'getp' [ 'string' 'block' ] [ 'this' ] ] trans:b ] ->  [#block, b],
    elem  [ 'binop' '===' [ 'getp' [ 'string' 'elem'  ] [ 'this' ] ] trans:b ] ->  [#elem, b],

    // block modifier
    mods [ 'binop' '==='
           [ 'getp' trans:m [ 'getp' [ 'string' 'mods' ] [ 'this' ] ] ]
           trans:v ]                                                           ->  [#blockMode, m, v],

    // elem modifier
    elemMods [ 'binop' '==='
               [ 'getp' trans:e [ 'getp' [ 'string' 'elemMods' ] [ 'this' ] ] ]
               trans:v ]                                                       ->  [#elemMode, e, v],

    mode  [ 'binop' '===' [ 'getp' [ 'string' '_mode' ] [ 'this' ] ] :b ] ->  [#_mode, b],

    // [#_mode, ['string', 'tag'], body]
    _mode :m :b trans([ 'stmt',
                        [ 'call',
                          [ 'getp', m, [ 'get', 'ctx' ] ],
                          [ 'stmt',
                            [ 'call',
                              [ 'func', null, [], [ 'begin', [ 'stmt', b ] ] ] ] ] ] ]),

    predicates = [#binop '&&' predicates:l predicates:r] -> l.concat(r)
        | :p trans([#block, p]):b                        -> [b]
        | :p trans([#elem, p]):b                         -> [b]
        | :p trans([#mode, p]):b                         -> [b]
        | :p trans([#mods, p]):b                         -> [b]
        | :p trans([#elemMods, p]):b                     -> [b]
        | trans:r                                        -> [[#pred, r]], //not used anywhere yet

    template = [#template predicates:ps  {this._extractBem(ps)}:p :body trans(p.mode.concat([body])):b] -> {
        'bh.match(' + p.bem + ', function (ctx, json) {'  + b + ';' + '})'
    },

    topLevel = [ template*:rs ] -> 'module.exports = function(bh) {' + rs.join('\n') + '}'

}

// Example: concatCodeStrings('"hi"', '"_"', '"bob"') returns '"hi_bob"'
XastToBh.prototype._concatCode = function concatCodeStrings() {
    return JSON.stringify(
        lo(arguments).
            toArray().
            flatten().
            map(JSON.parse).
            reduce(function(ac, s) {return ac + s;}, ''));
}

XastToBh.prototype._extractBem = function extractBem(predicates) {
    var block     = [],
        blockMode = [],
        elem      = [],
        elemMode  = [],
        preds     = [],
        mode;
    function _between(ar) {
        function separator(v) {return '"_"'};
        return lo.zip(
            lo.range(ar.length).map(separator),
            ar);
    }
    predicates.forEach(function(p) {
        var head = p[0],
        rest = lo.rest(p),
        len = rest.length;
        switch(head) {
        case 'block':
            block.push(rest);
            break;
        case 'elem':
            elem.push('"__"', rest);
            break;
        case 'blockMode':
            blockMode.push(_between(rest));
            break;
        case 'elemMode':
            elemMode.push(_between(rest));
            break;
        case '_mode':
            mode = p;
            break;
        default: preds.push(p);
        };
    });
    return {bem: this._concatCode(block, blockMode, elem, elemMode),
            predicates: preds,
            mode: mode};
}
