var ometajs = require('ometajs'),
    bp = require('../bp'),
    pp = bp.pp;
    xjstid = require('xjst').XJSTIdentity,
    bemhtml = require('./bemhtml'),
    bsjsparser = ometajs.grammars.BSJSParser,
    bsjsid = ometajs.grammars.BSJSIdentity,
    bsjstranslator = ometajs.grammars.BSJSTranslator,
    BEMHTMLToXJST = bemhtml.BEMHTMLToXJST,
    BEMHTMLParser = bemhtml.BEMHTMLParser,
    xjstjail = require('./jail').Jail,
    util = require('util'),
    assert = require('assert'),
    colors = require('colors'),
    lo = require('lodash');

ometa PredicClassifier <: bsjsid {

    getp = [#string #ctx]:fd [#this]:x {this._predic.ctx = true} -> [#getp, fd, x],

    getp = [#string :s ?(lo.contains(this._bemFields, s))]:fd [#this]:x {this._predic.bem = true}
        -> [#getp, fd, x],

    getp = [#string :s ?(lo.isString(s))]:fd [#this]:x {this._predic.custom = true}
        -> [#getp, fd, x],

    getp = ^getp,

    classifyPredic :bemFields
                   %(this._predic = {'ctx': false, 'bem': false, 'custom': false})
                   %(this._bemFields = bemFields)
         = trans -> this._predic
}

ometa BodyClassifier <:  xjstid {

    getp = [#string #ctx]:fd [#this]:x {this._body.ctx = true}  -> [#getp, fd, x],
    getp = ^getp,

    nhApplyStmt :p {this._body.apply = true} -> [#nhApplyStmt, p],
    nhApplyExpr    {this._body.apply = true} -> [#nhApplyExpr],
    applyStmt :p   {this._body.apply = true} -> [#applyStmt, p],

    localStmt trans:as trans:t {this._body.apply = true} -> [#localStmt, as, t],
    localExpr trans:as trans:t {this._body.apply = true} -> [#localExpr, as, t],

    classifyBody %(this._body = {'ctx': false, 'apply': false, 'js': false}) = trans -> this._body
}

ometa Classifier <: xjstid {

    bhPredic = [(#block | #blockMod | #elem | #elemMod):h anything+]:b -> b,

    bhPredic = [ #xjst
                 ([ 'unop' '!' [ 'getp' [ 'string' 'elem' ] [ 'this' ] ] ]
                  | :e {
                      this.
                          _class.
                          classifyPredic(
                              PredicClassifier.match(e, 'classifyPredic', [this._class._bemFields]));
                      return e;}) ]:b -> b,

    bhPredic = [:m] -> [m],

    bhBody = [#body [#begin [#stmt anything*]]]:b {this._class.addClass('3.3')} -> b,

    bhBody = [#body :b {
        this._class.classifyBody(BodyClassifier.match(b, 'classifyBody'));
        this._class.addClass('3.1') }] -> [#body, b],

    bhTemplate = [bhPredic+:ps bhBody:b] -> ps.concat([b])
        | [#stmt anything]:r -> r,

    start = [bhTemplate+:ts] -> ts,
    start = bhTemplate:t -> t,
    start = end -> [],

    topLevel %( this._class = new bp.Classes()) = start:t
        { this._class.addClass(t.length > 1 ? '1.2' : '1.1') }
            -> this._class

}

ometa Jail <: xjstjail {

    applyNext trans:e -> [#applyNext, e],
    applyNext -> [#applyNext],
    applyCtx trans:e -> [#applyCtx, e],
    topLevel = ^topLevel:r -> r
}

ometa Parser <: BEMHTMLParser {

    applyCase = "applyNext" "(" ")" -> [#applyNext]
        | "applyNext" "(" expr:e ")" -> [#applyNext, e]
        | "applyCtx" "(" expr:ctx ")" -> [#applyCtx, ctx],

    primExprHd = applyCase
        | ^primExprHd,

    stmt = applyCase
        | ^stmt,

    listBemMatchAndSet %(this.predicates = []) = bemMatchAndSet:t spaces
    ( ',' spaces listBemMatchAndSet:ts -> {
        BEMHTMLParser._concatChildren(t, ts)
    } | '{' spaces listBemMatchAndSet+:ts spaces '}'
      spaces -> {
          BEMHTMLParser._concatChildren(t, [#sub, ts])
      } | ':' (asgnExpr:e -> [#begin, [#return, e]]
               | stmt):c ','? ->
      [t, [#body, Jail.match(
          c,
          'topLevel',
          ['_$' + (BEMHTMLParser._jailId++).toString(36)]
      )]]
    ):r -> {
        if (this.predicates.length === 0) return r;
        BEMHTMLParser._concatChildren(
            [#xjst, this.predicates],
            r
        )
    } | ^stmt:r -> [#stmt, r],

    topLevel = ^topLevel

}

ometa HashArg <: bsjsid {

    json trans*:props -> ([#seqStmts].concat(props)),
    binding :name {Parser.matchAll('this.' + name, 'stmt')}:prop :val -> ([#set, prop, val]),

}

// consider refactoring this grammar into a tree transformer with a
// separate one responsible for code generation
ometa XastToBh <: bsjstranslator {

    fail :msg =  {this.pushError(msg)} ?(false),

    // bemhtml parser adds an extra 'undefined' statement to some template bodies
    // ignore them
    stmt [#get #undefined] -> '',
    stmt = ^stmt,

    seqStmts = trans*:ts -> ts.join(';'),

    contextMethods = 'isFirst' | 'isLast' | 'generateId' | 'extend' | 'isSimple',
    thisCtx = [ 'string' 'ctx' ] [ 'this' ],
    thisPosition = [ 'string' 'position' ]:p [ 'this' ] -> p,
    thisMethods = [ 'string' contextMethods ]:m [ 'this' ] -> m,
    thisBlockOrElem = ['string' ('block' | 'elem') ]:p [ 'this' ] -> p,
    this_ = ['string' '_'] ['this'],
    thisMods = [ 'string' ('mods' | 'elemMods') ] [ 'this' ],
    getpThisMods = ['getp' thisMods],

    set = [ #getp :p getpThisMods ] :v trans(this.astOf.mod(p, v))
        | [ #getp :p [ #this ]] :v trans(this.astOf.tParam(p, v))
        | ^ set,

    getp =  thisCtx trans(this.astOf.json)
        | thisPosition:p trans([#call, this.astOf.getp(p)])
        | thisMethods:m trans(this.astOf.getp(m))
        | thisBlockOrElem:p trans(this.astOf.getp(p, this.astOf.json))
        | this_ trans([#get, 'ctx'])
        | :p getpThisMods trans(this.astOf.mod(p))
        | :p [ #this ]  trans(this.astOf.tParam(p))
        | ^getp,

    applyNext = :e (isMode('default') {HashArg.match(e, 'trans')}:arg trans(arg)
                     | fail('returning result of applyNext(args)'))
        | ~isMode('default') trans(this.astOf[this._m]())
        | isMode('default') -> '',

    applyCtx = :e trans([#return, e]),

    force -> ['get', 'true'],
    isJson [#json (anything*)],
    isArray [#arr (anything*)],
    mixBody :b = (isJson(b) -> [#arr, b]
                  | isArray(b) -> b
                  | fail('in mix: expected an Object or an Array')),
    jsBody trans:body -> this.parse('this.ctx.js !== false ? this.extend(this.ctx.js,' + body + ') : false'),

    attrsBody :body -> this.astOf.callMethod('extend', ['this'])(body, this.astOf.attrs()),

    _mode %(this._m = '') = [#string :m] { this._m = m } bhBody:body
        ( ?(m === 'default')  trans(body)
          | ?(m === 'mix') mixBody(body):mbody trans([#stmt,
                                                      this.astOf.mix(
                                                          this.astOf
                                                              .callMethod('concat', mbody)(this.astOf.mix()))])
          | ?(m === 'js') jsBody(body):jsbody trans([#stmt, this.astOf.js(jsbody)])
          | ?(m === 'attrs') attrsBody(body):abody trans([#stmt, this.astOf.attrs(abody)])
          | force:f trans([ #stmt, this.astOf.callCtx(m)(body, f) ])),

    isMode :m = ?(this._m === m),

    bhBody = [#body [#begin [#return :b]]] -> b
        | [#body [#begin [#stmt [#return :b]]]] -> b
        | [#body [#begin (anything*):ss]] isMode('default') -> ([#seqStmts].concat(ss))
        | [#body :b] -> this.astOf.iif(b),

    bhPredic = [ (#block | #blockMod | #elem | #elemMod):h trans+:b] -> [h].concat(b)
        | [:m] -> [#_mode, [#string, m]]
        | [#xjst trans:e] -> [#pred, e],

    notElem = [#xjst [ 'unop' '!' [ 'getp' [ 'string' 'elem' ] [ 'this' ] ] ]],

    bhTemplate = [ notElem?
                   bhPredic+:ps
                   { this._extractBem(ps) }:p
                   :body
                   trans(p.mode.concat([body])):b ]
                 -> { p.body = body; p.b = b; return p; },

    topLevel = [ bhTemplate+:ts ] { this._bhMatches(ts) }:ms
               -> new bp.Bh('module.exports = function(bh) {' + ms + '}')

}

function _call(method, ofWhat) {
    return function() {
        return ['call',
                ['getp',
                 lo.isString(method) && ['string', method] || method,
                 lo.isString(ofWhat) && ['get', ofWhat] || ofWhat]
               ].concat(lo.toArray(arguments));
    }
}

var ofCtx = lo.partialRight(_call, 'ctx');

// function ctxCall(what) {
//     return function() {
//         return ['call',
//                 ['getp',
//                  lo.isString(what) && ['string', what] || what,
//                  ['get', 'ctx']]
//                ].concat(lo.toArray(arguments));
//     }
// }

XastToBh.prototype.pushError = function pushError(msg) {
    this._errorStack || (this._errorStack = new Error());
    var report = this._errorStack.report || (this._errorStack.report = []);
    report.push(msg);
}

XastToBh.prototype.parse = function parse(code) {
    return bsjsparser.matchAll(code, 'stmt');
}

XastToBh.prototype.astOf =  {
    json        : ['get', 'json'],
    content     : ofCtx('content'),
    applyBase   : ofCtx('applyBase'),
    mod         : ofCtx('mod'),
    attrs       : ofCtx('attrs'),
    tParam      : ofCtx('tParam'),
    mix         : ofCtx('mix'),
    js          : ofCtx('js'),
    getp        : function(field, from) {
        return ['getp', lo.isString(field) && ['stirng', field] || field, from || ['get', 'ctx']];
    },
    iif         : function(body) { return [ 'call', [ 'func', null, [], body ] ];},
    stmt        : function() { return ['stmt'].concat(lo.toArray(arguments)); },
    callMethod  : _call,
    callCtx     : ofCtx
};

XastToBh.prototype._extractBem = function extractBem(predicates) {
    var block = [],
    blockMod  = [],
    elem      = [],
    elemMod   = [],
    preds     = [],
    mode,
    that      = this;

    predicates.forEach(function(p) {
        var head = p[0],
        rest = lo.rest(p),
        len = rest.length,
        sep = '"_"';
        switch(head) {
        case 'block':
            block.push(rest);
            break;
        case 'elem':
            elem.push('"__"', rest);
            break;
        case 'blockMod':
            blockMod.push(that._between(rest, sep));
            break;
        case 'elemMod':
            elemMod.push(that._between(rest, sep));
            break;
        case '_mode':
            mode = p;
            break;
        default: preds.push(rest);
        };
    });
    return {bem: that._concatCode(block, blockMod, elem, elemMod),
            predicates: preds,
            mode: mode};
}

XastToBh.prototype._bhMatches = function _bhMatches(ts) {
    var result = lo(ts)
        .groupBy('bem')
        .map(this._nestTemplates)
        .reduce(function(a, s){return a + s;}, '');
    //pp(lo(ts).groupBy('bem').value(), {prompt: 'grouped'});
    return result;
}

XastToBh.prototype._between = function _between(ar, sep, sepSecond) {
    var len = ar.length;
    sep = sep ? sep : '"_"';
    function separator(v) {return sep};
    return sepSecond ?
        lo.flatten(lo.zip(ar, lo.range(len).map(separator)).slice(0, len - 1)) : //chop off redundant sep
        lo.zip(lo.range(len).map(separator), ar);
}

// might be sensible to rewrite this using xjst, seeing how it its pattern
XastToBh.prototype._nestTemplates = function _nestTemplates(ts, bem) {

    // find default mode and return it's body-string, empty string otherwise
    // remove it from ts
    function extractDefault() {
        var defMode = [ '_mode', [ 'string', 'default' ] ],
            isDefault = function(t){return lo.isEqual(t.mode, defMode);},
            defIndex = lo.findIndex(ts, isDefault);
        return defIndex >= 0 ? ts.splice(defIndex, 1).pop().b : '';
    }

    function diffPredicates(from, which) {
        return lo.reject(
            from,
            function (pf) {return lo.any(which,
                              function (pw) {return lo.isEqual(pf, pw)})})}

    function _nestTemplate(t, predicates) {
        var t, restOfPredicates;

        // nesting
        restOfPredicates = diffPredicates(t.predicates, predicates);
        return restOfPredicates.length > 0 ?
            'if(' + restOfPredicates.join(' && ') + '){' +
            _nestTemplate(t, lo.union(predicates, restOfPredicates)) + '}' :
            t.b + ';';
    }

    return 'bh.match(' + bem + ', function (ctx, json) {'  +
        extractDefault() + ts
            .map(function(t) {return _nestTemplate(t, []);})
            .reduce(function(a, s){return a + s;}, '') + '});';
}

// Example: concatCodeStrings('"hi"', '"_"', '"bob"') returns '"hi_bob"'
XastToBh.prototype._concatCode = function concatCodeStrings() {
    return JSON.stringify(
        lo(arguments).
            toArray().
            flatten().
            map(JSON.parse).
            reduce(function(ac, s) {return ac + s;}, ''));
}
